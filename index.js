#!/usr/bin/env node
'use strict';
const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');
const argv = require('minimist')(process.argv.slice(2));
const glob = require('glob');
const ts = require('typescript');

const TRANSLATIONS_FILENAME = 'drupal-gutenberg-translations.js';
// see https://github.com/WordPress/gutenberg/blob/master/packages/i18n/src/index.js
const I18N_FUNCTIONS = ['__', '_x', '_n', '_nx'];

// const source = argv._.length < 2 ? ['.'] : argv._[0] || ['.'];
// const target = argv._.length < 2 ? argv._[0] : argv._[1] || ['./js'];
const target = argv._[0] || './js';

// Read the "--verbose" flag.
const verbose = argv.verbose || false;

// Match only on .js files.
const fileMatch = './**/*.js';
// Ignore
const globOptions = {
  ignore: ['./node_modules/**', './**/*.es6.js']
};

const warning = (warning) => {
  console.warn(chalk.keyword('orange')(warning));
};

const processFiles = (error, filePaths) => {
  if (error) {
    // process.exitCode = 1;
  }

  fs.ensureFileSync(path.join(target, TRANSLATIONS_FILENAME), err => {
    console.log(err); // => null
  });

  let content = `/*\n\tFile generated by drupal-gutenberg-translations tool.\n*/\n/*\n`;

  // Process the current entry.
  const processEntry = (entry) => {
    let functionName = entry.functionName;
    let key = entry.key;
    let optionsArgument = entry.optionsArgument;

    if (functionName === '__' || functionName === '_x') {
      let argumentValues = `${key}`;
      if (functionName === '_x' && optionsArgument[0]) {
        argumentValues += `, {}, {context:${optionsArgument[0]}}`;
      }
      content += `\tDrupal.t(${argumentValues});\n`;
    }
    else if (functionName === '_n' || functionName === '_nx') {
      let single = key;
      let plural = optionsArgument[0];
      let number = optionsArgument[1] || 1; // If a variable was used, default to 1.
      if (single && plural && number) {
        let argumentValues = `${number}, ${single}, ${plural}`;
        if (functionName === '_nx' && optionsArgument[2]) {
          argumentValues += `,{},{context:${optionsArgument[2]}}`;
        }
        content += `\tDrupal.formatPlural(${argumentValues});\n`;
      }
    }
  };

  // Parse a node tree.
  const parseTree = (node, sourceFile) => {
    let entry;

    if (node.kind === ts.SyntaxKind.CallExpression) {
      entry = expressionExtractor(node, sourceFile);
    }

    if (entry) {
      if (verbose) {
        if (!sourceFile.processedDrupalTranslation) {
          content += `\t// File ./${sourceFile.fileName}\n`;
          sourceFile.processedDrupalTranslation = true;
        }
      }
      processEntry(entry);
    }

    node.forEachChild((node) => parseTree(node, sourceFile))
  };

  /**
   * Extract calls to '__', '_x', '_n' and '_nx'.
   */
  const expressionExtractor = (node, sourceFile) => {
    const entry = {};

    let isTranslationFunction = false;

    if (node.expression.text && I18N_FUNCTIONS.includes(node.expression.text)) {
      isTranslationFunction = true;
      entry.functionName = node.expression.text;
    }
    else if (node.expression.name && I18N_FUNCTIONS.includes(node.expression.name.text)) {
      isTranslationFunction = true;
      entry.functionName = node.expression.name.text;
    }
    else {
      let firstArgument;

      if (ts.SyntaxKind.CallExpression === node.expression.kind && node.expression.arguments[0]) {
        firstArgument = node.expression.arguments[0];
      }
      else if (ts.SyntaxKind.ParenthesizedExpression === node.expression.kind && node.expression.expression) {
        firstArgument = node.expression.expression;
      }
      if (firstArgument) {
        let callName = '';
        if (firstArgument.kind === ts.SyntaxKind.PropertyAccessExpression) {
          // Detect calls like "Object(_reference._n)(...)"
          callName = firstArgument.name.text;
        } else if (firstArgument.text) {
          callName = firstArgument.text;
        }

        if (callName && I18N_FUNCTIONS.includes(callName)) {
          isTranslationFunction = true;
          entry.functionName = callName;
        }
      }
    }

    if (!isTranslationFunction || !node.arguments || !node.arguments.length) {
      return null;
    }

    const argumentValue = node.arguments.shift();

    if (argumentValue && argumentValue.kind === ts.SyntaxKind.StringLiteral) {
      entry.key = JSON.stringify(argumentValue.text);
    }
    else if (argumentValue && argumentValue.kind === ts.SyntaxKind.BinaryExpression) {
      const concatenatedString = concatenateString(argumentValue);
      if (!concatenatedString) {
        warning(`Key is not a string literal: ${argumentValue.text}`);
        return null;
      }
      entry.key = JSON.stringify(concatenatedString);
    }
    else {
      if (argumentValue.kind === ts.SyntaxKind.Identifier) {
        warning(`Key is not a string literal: ${argumentValue.text}`);
      }

      return null;
    }

    entry.optionsArgument = node.arguments.map((argumentValue) => {
      if (!argumentValue) {
        return;
      }
      if (argumentValue.kind === ts.SyntaxKind.StringLiteral) {
        return JSON.stringify(argumentValue.text);
      }
      else if (argumentValue.kind === ts.SyntaxKind.BinaryExpression) {
        const concatenatedString = concatenateString(argumentValue);
        if (!concatenatedString) {
          warning(`Argument value is not a string literal: ${argumentValue.text}`);
          return null;
        }
        return JSON.stringify(concatenatedString);
      }
      else if (argumentValue.kind === ts.SyntaxKind.NumericLiteral) {
        return parseInt(argumentValue.text);
      }
      else if (argumentValue.kind === ts.SyntaxKind.ObjectLiteralExpression) {
        let object = {};
        for (const p of argumentValue.properties) {
          object[p.name.text] = p.initializer && p.initializer.text || '';
        }
        return JSON.stringify(object);
      }
      else if (verbose) {
        warning(`Argument value type "${ts.SyntaxKind[argumentValue.kind]}" not supported: ${argumentValue.getText(sourceFile)}`);
      }
    });

    return entry;
  };

  // Concatenate a binary string expression.
  const concatenateString = (binaryExpression, string = '') => {
    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.PlusToken) {
      return;
    }

    if (binaryExpression.left.kind === ts.SyntaxKind.BinaryExpression) {
      string += concatenateString(binaryExpression.left, string);
    }
    else if (binaryExpression.left.kind === ts.SyntaxKind.StringLiteral) {
      string += binaryExpression.left.text;
    }
    else {
      return;
    }

    if (binaryExpression.right.kind === ts.SyntaxKind.BinaryExpression) {
      string += concatenateString(binaryExpression.right, string);
    }
    else if (binaryExpression.right.kind === ts.SyntaxKind.StringLiteral) {
      string += binaryExpression.right.text;
    }
    else {
      return;
    }

    return string;
  };

  filePaths.forEach(filePath => {
    if (verbose) {
      console.log(`Parsing ${filePath}`);
    }

    const data = fs.readFileSync(filePath, {encoding: 'utf-8'});
    const sourceFile = ts.createSourceFile(filePath, data, ts.ScriptTarget.Latest);
    parseTree(sourceFile, sourceFile);
  });

  content += '*/\n';

  fs.writeFileSync(path.join(target, TRANSLATIONS_FILENAME), content);
};

console.log(`${chalk.red('üè≥ Drupal Gutenberg Translations Builder')}`);
console.log(`${chalk.green('Target file')}: ${chalk.white(path.join(target, TRANSLATIONS_FILENAME))}`);

try {
  glob(fileMatch, globOptions, processFiles);
}
catch (error) {
  console.error(error);
}
